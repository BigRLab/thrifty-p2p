== thrifty-p2p ==

A very simple p2p python implementation using the Thrift protocol and
its basic RPC capabilities. It is not expected to be generically usable
by arbitrary projects: thrifty-p2p implements a flat network, which is
justifiable for the author's purposes, but will encounter trouble
scaling.

=== Basic usage ===

  python location.py [[peer_node] port_num]

Initiates and/or joins a simple peer-to-peer network. Default port_num
is 9900. Absent a peer_node (which is the peer initially contacted for
joining the network), the command initiates a network.

Example usage, in different terminal windows:
  python location.py
  
  python location.py localhost:9900 9901
  
  python location.py localhost:9901 9902
  
... etc. ...

=== Dependencies & Requirements ===

The basic server uses consistent hashing via hash_ring.py, developed by
Amir Salihefendic. For better and for worse, I modified the code to
allow for easier node set manipulations and different node resolution
behavior so that it's more trivially related to md5 hashes.

The library requires the Apache Thrift Python libraries to be installed,
but does not currently technically require the Thrift compiler or any
other language libraries.

=== Design priorities ===

I'm using Thrift as much for its simple RPC underpinnings as the message
format. I wanted to consistently distribute some processing and bother
as little as possible with node lookup. This is the simplest thing that
I came up with that sort-of works: a flat peer-to-peer network with each
node keeping up with the state of all the nodes as well as it can. This
necessarily limits the ring's ability to scale beyond dozens of nodes.

== diststore ==

Diststore is an example application that can be layered atop the 
thrifty-p2p location service. It's a toy distributed key-value store,
like all the kids are doing these days. It makes no attempt to optimize
for large scales, so don't get too excited about deploying this anywhere
real. 

Although diststore.thrift uses locator.thrift for a lot of its interfaces,
the implementation overloads many of the base methods. Let's hope it ends
up an informative example for either one of us. 

Example usage, run this in a couple terminal windows:
  python storeserver.py
  
Then in another window start populating the store:
  python storeput.py a apple
  python storeput.py b banana
  python storeput.py c crayon
  python storeput.py d dinosaur

You can then query the store:
  python storeget.py c
  
or start a new server, and see how a minimum of the existing keys 
redistribute themselves:
  python storeserver.py
  
or even stop a server with ctrl-C or a `kill -INT` signal and see 
how the server hands its items off gracefully. However, the system 
is not robust to any more aggressive termination: keys will go missing.
